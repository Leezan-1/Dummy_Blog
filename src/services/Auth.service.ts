// built-in & third party modules

// configs and resources 

// enums ans constants

// schemas, interfaces
import { LoginFormSchema, PasswordFormSchema, SignUpFormSchema } from "../schemas/multipleFieldsForm.schema";
import { LoginForm, PasswordForm, SignUpForm } from "../interfaces/Forms.interface";

// models and services
import { User } from "../models/User";

// utility functions & classes
import CustomError from "../utils/CustomError.utils";
import { checkUserPassword, generatePassword } from "../utils/generate.utils";


class AuthService {
    static async getUserByEmail(email: string): Promise<User> {

        // user generated by this function is used all over the server.
        const user = await User.findOne({ where: { email: email } });
        if (!user)
            throw new CustomError(401, "user does not exist");
        return user;
    }


    static async getUserById(id: number) {
        const user = await User.findByPk(id);
        if (!user)
            throw new CustomError(401, "user does not exist");
        return user;
    }


    // signs up a new user
    static async signUpUser(signupInfo: SignUpForm) {

        let { fname, lname, email, password } = SignUpFormSchema.parse(signupInfo);

        // checks if there is any other user with same email address.
        const existingUser = await User.findOne({ where: { email: email }, raw: true });
        if (existingUser)
            throw new CustomError(401, "user already exists");

        // stores hashed password for user.
        let hashedPassword = await generatePassword(password);

        // auto generates username for new user
        let username = email.split("@")[0];

        // creates a new user.
        return User.create({
            first_name: fname,
            last_name: lname,
            username: username,
            email: email,
            password: hashedPassword
        });
    }


    static async loginUser(loginInfo: LoginForm) {

        let { email, password } = LoginFormSchema.parse(loginInfo);

        // checks the email and password of the user in database
        let existingUser = await this.getUserByEmail(email);
        if (!existingUser.verified)
            throw new CustomError(401, "email is not verified");

        if (!existingUser || ! await checkUserPassword(password, existingUser.password))
            throw new CustomError(401, "email or password did not match");

        return existingUser;
    }

    static async verifyEmail(userId: number, reqBodyEmail: string) {
        const user = await this.getUserById(userId);

        // this is because userId comes through validate Otp jwt
        if (reqBodyEmail != user.email)
            throw new CustomError(406, "invalid otp for given email");

        if (user.verified)
            throw new CustomError(400, "user already verified");

        user.verified = true;
        user.save();
    }

    static async resetPassword(passwordFields: PasswordForm, userId: number) {

        let { newPassword, confirmPassword } = PasswordFormSchema.parse(passwordFields);

        const user = await this.getUserById(userId);

        user.update({ password: await generatePassword(newPassword) });

    }
}

export default AuthService;