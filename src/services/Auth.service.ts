// this service handles login authentication and authorization
import { LoginForm, SignUpForm } from "../interfaces/UserForm.interface";

// utils functions
import { validateEmail, validateName, validatePswd } from "../utils/validation.utils";
import CustomError from "../utils/CustomError.utils";
import { checkUserPassword, generatePassword } from "../utils/generatePassword.utils";

// Models
import { User } from "../models/User";

export class AuthService {
    static async getUserByEmail(email: string): Promise<User | null> {

        // user generated by this function is used all over the server.
        const user = await User.findOne({ where: { email: email }, raw: true });
        return user;
    }

    // signs up a new user
    static async signUpUser(userFormInfo: Required<SignUpForm>) {

        let { fname, lname, email, password } = userFormInfo;
        validateName(fname);
        validateName(lname);
        validateEmail(email);
        validatePswd(password);

        // checks if there is any other user with same email address.
        const userExists = await this.getUserByEmail(email);
        if (userExists!)
            throw new CustomError(401, "User Already Exists");

        // stores hashed password for user.
        let hashedPassword = await generatePassword(password);

        // auto generates username for new user
        let username = email.split('@')[0];

        // creates a new user.
        await User.create({
            first_name: fname,
            last_name: lname,
            username: username,
            email: email,
            password: hashedPassword
        });
    }

    static async loginUser(userFormInfo: Required<LoginForm>) {

        let { email, password } = userFormInfo;
        validateEmail(email);
        validatePswd(password);

        // checks the email and password of the user in database
        let existingUser = await this.getUserByEmail(userFormInfo.email);
        if (!existingUser || ! await checkUserPassword(password, existingUser.password))
            throw new CustomError(403, "email or password did not match");

        return existingUser;
    }
}