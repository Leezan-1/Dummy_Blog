// this service handles login authentication and authorization

//import schema
import { EmailSchema, LoginForm, LoginFormSchema, RegenPasswordSchema, SignUpForm, SignUpFormSchema } from "../schemas/userForm.schema";

// utils functions
import CustomError from "../utils/CustomError.utils";
import { checkUserPassword, generateOTPToken, generatePassword } from "../utils/generate.utils";

// Models
import { User } from "../models/User";
import { Otp } from "../models/Otp";

export class AuthService {
    static async getUserByEmail(email: string): Promise<User> {

        // user generated by this function is used all over the server.
        const user = await User.findOne({ where: { email: email }, raw: true });
        if (!user)
            throw new CustomError(401, "User Already Exists");
        return user;
    }

    // signs up a new user
    static async signUpUser(signupInfo: SignUpForm) {

        let parsedBody = SignUpFormSchema.safeParse(signupInfo);

        if (!parsedBody.success) {
            const errMsg = parsedBody.error.errors[0];
            throw new CustomError(400, errMsg.message, errMsg);
        }

        let { fname, lname, email, password } = parsedBody.data;

        // checks if there is any other user with same email address.
        const userExists = await this.getUserByEmail(email);

        // stores hashed password for user.
        let hashedPassword = await generatePassword(password);

        // auto generates username for new user
        let username = email.split("@")[0];

        // creates a new user.
        await User.create({
            first_name: fname,
            last_name: lname,
            username: username,
            email: email,
            password: hashedPassword
        });
    }

    static async loginUser(loginInfo: LoginForm) {

        const parsedBody = LoginFormSchema.safeParse(loginInfo);

        if (!parsedBody.success) {
            const errMsg = parsedBody.error.errors[0].message;

            //ERRORFIX make errors obj more user friendly
            throw new CustomError(400, errMsg, parsedBody.error.errors);
        }

        let { email, password } = parsedBody.data;

        // checks the email and password of the user in database
        let existingUser = await this.getUserByEmail(email);

        if (!existingUser || ! await checkUserPassword(password, existingUser.password))
            throw new CustomError(403, "email or password did not match");

        return existingUser;
    }

    static async sendOtpToken(userEmail: string) {

        const parsedBody = EmailSchema.safeParse(userEmail);

        if (!parsedBody.success) {
            const errObj = parsedBody.error.errors;
            throw new CustomError(400, "invalid form input", errObj)
        }

        await Otp.create({
            email: userEmail,
            token: generateOTPToken()
        });
    }

    static async checkOtpToken(email: string, token: string) {

        const tokenExist = await Otp.findOne({
            where: { email: email, token: token }
        });

        console.log('tokenExist.createdAt :>> ', tokenExist?.createdAt, typeof tokenExist);
        // if (tokenExist?.createdAt)

        if (!tokenExist)
            throw new CustomError(400, "invalid otp token");

        return {
            email: email,
            token: token,
            otp_Valid: true
        }

    }

    static async newPassword(passwordFields: object) {

        const parsedBody = RegenPasswordSchema?.safeParse(passwordFields);
        if (!parsedBody.success) {
            const errObj = parsedBody.error.errors;
            throw new CustomError(400, "invalid form fields", errObj);
        }

        const { oldPassword, newPassword, email } = parsedBody.data;
        if (oldPassword == newPassword) {
            throw new CustomError(400, "old password cannot be same as new password");
        }

        const user = await this.getUserByEmail(email);

        if (!await checkUserPassword(oldPassword, user?.password!))
            throw new CustomError(400, "incorrect old password");

        await user.update(
            { password: await generatePassword(newPassword) },
            { where: { email: email } })

    }
}