// this service handles login authentication and authorization

//import schema
import { LoginForm, LoginFormSchema, SignUpForm, SignUpFormSchema } from "../schemas/userForm.schema";

// utils functions
import CustomError from "../utils/CustomError.utils";
import { checkUserPassword, generatePassword } from "../utils/generate.utils";

// Models
import { User } from "../models/User";

export class AuthService {
    static async getUserByEmail(email: string): Promise<User | null> {

        // user generated by this function is used all over the server.
        const user = await User.findOne({ where: { email: email }, raw: true });
        return user;
    }

    // signs up a new user
    static async signUpUser(signupInfo: SignUpForm) {

        let parsedBody = SignUpFormSchema.safeParse(signupInfo);

        if (!parsedBody.success) {
            const errMsg = parsedBody.error.errors[0];
            throw new CustomError(400, errMsg.message, errMsg);
        }

        let { fname, lname, email, password } = parsedBody.data;

        // checks if there is any other user with same email address.
        const userExists = await this.getUserByEmail(email);
        if (userExists!)
            throw new CustomError(401, "User Already Exists");

        // stores hashed password for user.
        let hashedPassword = await generatePassword(password);

        // auto generates username for new user
        let username = email.split('@')[0];

        // creates a new user.
        await User.create({
            first_name: fname,
            last_name: lname,
            username: username,
            email: email,
            password: hashedPassword
        });
    }

    static async loginUser(loginInfo: LoginForm) {

        const parsedBody = LoginFormSchema.safeParse(loginInfo);

        if (!parsedBody.success) {
            const errMsg = parsedBody.error.errors[0].message;

            //ERRORFIX make errors obj more user friendly
            throw new CustomError(400, errMsg, parsedBody.error.errors);
        }

        let { email, password } = parsedBody.data;

        // checks the email and password of the user in database
        let existingUser = await this.getUserByEmail(email);

        if (!existingUser || ! await checkUserPassword(password, existingUser.password))
            throw new CustomError(403, "email or password did not match");

        return existingUser;
    }
}