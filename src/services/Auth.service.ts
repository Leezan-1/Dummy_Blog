// this service handles login authentication and authorization

//import schema
import { EmailSchema, LoginForm, LoginFormSchema, NameSchema, RegenPasswordSchema, SignUpForm, SignUpFormSchema } from "../schemas/userForm.schema";

// utils functions
import CustomError from "../utils/CustomError.utils";
import { checkUserPassword, generateOTPToken, generatePassword } from "../utils/generate.utils";

// Models
import { User } from "../models/User";
import { Otp } from "../models/Otp";
import { transporter } from "../config/mailtrap.config";

export class AuthService {
    static async getUserByEmail(email: string): Promise<User> {

        // user generated by this function is used all over the server.
        const user = await User.findOne({ where: { email: email }, raw: true });
        if (!user)
            throw new CustomError(401, "user does not exist");
        return user;
    }

    // signs up a new user
    static async signUpUser(signupInfo: SignUpForm) {

        let { fname, lname, email, password } = SignUpFormSchema.parse(signupInfo);

        // checks if there is any other user with same email address.
        const existingUser = await User.findOne({ where: { email: email }, raw: true });
        if (existingUser)
            throw new CustomError(401, "user already exists");

        // stores hashed password for user.
        let hashedPassword = await generatePassword(password);

        // auto generates username for new user
        let username = email.split("@")[0];

        // creates a new user.
        await User.create({
            first_name: fname,
            last_name: lname,
            username: username,
            email: email,
            password: hashedPassword
        });
    }

    static async loginUser(loginInfo: LoginForm) {

        let { email, password } = LoginFormSchema.parse(loginInfo);

        // checks the email and password of the user in database
        let existingUser = await this.getUserByEmail(email);

        if (!existingUser || ! await checkUserPassword(password, existingUser.password))
            throw new CustomError(403, "email or password did not match");

        return existingUser;
    }

    static async sendOtpToken(userEmail: string) {

        const parsedEmail = EmailSchema.parse(userEmail);

        if (!await transporter.verify())
            throw new Error("unable connect to mail server");

        const otpToken = generateOTPToken();

        const MAIL_MSG = {
            from: `'BlogPost' <no-reply@${process.env.APP_NAME}>`,
            to: parsedEmail,
            subject: 'reset password',
            text: `Your OTP token is ${otpToken}`
        };

        try {
            const info = transporter.sendMail(MAIL_MSG);
            await Otp.create({
                email: parsedEmail,
                token: otpToken
            });
        } catch (error) {
            console.error(error);
        }

    }

    static async checkOtpToken(email: string, token: string) {

        const parsedEmail = EmailSchema.parse(email)
        // const parsedToken = NameSchema.parse(token);

        const tokenExist = await Otp.findOne({
            where: { email: parsedEmail, token: token }
        });

        // if (tokenExist?.createdAt)

        if (!tokenExist)
            throw new CustomError(400, "invalid otp token");

        console.log('tokenExist.createdAt :>> ', tokenExist?.createdAt, typeof tokenExist);
        return {
            email: email,
            token: token,
            otp_Valid: true
        }

    }

    static async newPassword(passwordFields: object) {

        const parsedBody = RegenPasswordSchema?.safeParse(passwordFields);
        if (!parsedBody.success) {
            const errObj = parsedBody.error.errors;
            throw new CustomError(400, "invalid form fields");
        }

        const { oldPassword, newPassword, email } = parsedBody.data;
        if (oldPassword == newPassword) {
            throw new CustomError(400, "old password cannot be same as new password");
        }

        const user = await this.getUserByEmail(email);

        if (!await checkUserPassword(oldPassword, user?.password!))
            throw new CustomError(400, "incorrect old password");

        await user.update(
            { password: await generatePassword(newPassword) },
            { where: { email: email } })

    }
}